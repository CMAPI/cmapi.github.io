var cmapi = cmapi || {};
cmapi.channel = cmapi.channel || {};
cmapi.overview = cmapi.overview || {};cmapi.overview["cmapi.acknowledgements"] = {
	"sections": [{
		"title": "CMAPI Editors",
		"paragraphs": [
			"Chris Bashioum - cbashioum@mitre.org",
			"Eric Briscoe - eric.j.briscoe@gmail.com",
			"Scott Hammonds - "
		]
	},
	{
		"title": "CMAPI Contributors",
		"paragraphs": [
			"Collecting list of contributors..."
		]
	}]
};cmapi.overview["cmapi.acronyms"] = {
	"sections": [{
		"title": "Acronyms",
		"paragraphs": [
			"API - Application Program Interface",
			"GeoJSON - 	Geospatial JavaScript Object Notation",
			"GUI - Graphical User Interface",
			"KML - Keyhole Markup Language",
			"Lat - Latitude",
			"Lon - Longitude",
			"OWF - OZONE Widget Framework ",
			"URL - Uniform Resource Locator",
			"WMS - Web Map Service",
			"OGC - Open Geospatial Consortium",
			"RFC - Request For Comment"
		]
	}]
};cmapi.overview["cmapi.appendecies.overview"] = {
  "title": "CMAPI Appendecies",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This sections lists appendecies for the CMAPI specification"
    ]
  }]
};
cmapi.overview["cmapi.appendix.a"] = {
  "title": "Appendix A: Unique Identifiers",
  "sections": [{
    "title": "Unique Identifiers",
    "paragraphs": [
      "Because many different widgets may send messages over the CMAPI asynchronously, the importance of being able to ensure items such as overlayId and messageId are globally unique cannot be stressed enough.  If items that the CMAPI indicates SHOULD or MUST be globally unique, or unique to an overlay, etc., are not in fact unique, “strange” behavior becomes a real possibility.  Although guaranteeing true global uniqueness is not possible, to achieve the highest probable possibility of global uniqueness, identifiers SHOULD use UUID (also referred to as GUID) formatted identifiers generated according to RFC 4122 (<a href=\"http://www.ietf.org/rfc/rfc4122.txt\">http://www.ietf.org/rfc/rfc4122.txt</a>). Widgets MAY format identifiers any way they choose (e.g., human readable), but widgets SHOULD either prepend or append the RFC 4122 conformant UUID to the chosen identifier.  In any case, the component sending the message SHALL be responsible for handling errors relating to identifier conflicts generated by the receiving application.",
      "Some Environments such as the OWF 7 OWF.Util.guid() method provide a utility to generate valid UUIDs.  It is recommended applications utilize existing well known UUID generators when possible."
    ]
  }]
};
cmapi.overview["cmapi.changelog"] = {
  "title": "CMAPI 1.3.0 Change Log",
  "sections": [{
    "title": "Changes",
    "paragraphs": [
      "There are no changes between CMAPI 1.2.0 and 1.3.0 that break backwards compatibility. There are some behaviors that have been deprecated that will require changes in a future version of CMAPI and break backwards compatibility.  Please see the deprecation section for more details.",
      "A section for Runtime Extensions has been added which indicates CMAPI related behavior in a particular runtime such as Ozone Widget Framework.  These extensions should be followed when developing a solution that will use CMAPI in the listed runtimes.  The goal of this is to eliminate any runtime specific functionality from the core specification so it can be used in any runtime that supports pub / sub messaging.",
      "Feature data formats for the map.feature channels was previously listed in the CMAPI appendeies.  The data formats now have their own section titled map.feature Data Formats and the appendice letters have subsequently changed for the remaining appendicies.",
      "The documentation for each channel is now generated from JSON schema files.  These same JSON schemas can be used to validate CMAPI message payload objects.  At the bottom of each channel definition there is an example payload that will validate via the schema for that channel.  This validation can also be used in your application.  See the section title Validating CMAPI messages for more information."
    ]
  }, {
    "title": "Additions",
    "paragraphs": [
      "Added new batch channels for map.feature.plot.batch, map.feature.unplot.batch, map.feature.selected.batch, map.feature.deselected.batch.  these cahnnels are inteded to be used in place of sending an array of payloads, which is now a deprecated",
      "Added the map.status.initialization channel which provides indication when a map is available to receive messages",
      "Added definitions for symbology feature types including MIL-STD-2525B and MIL-STD 2525C",
      "Added recomendation to use UUID's for all ids.  This can be found in the overview page.",
      "Added User Manipulation Extension which adds capabilities including feature drawing, feature editing, feature click events, and message complete callbacks",
      "A new properties object was added to many channels as a free form object container for addtional attributes to send with a message payload without polluting the root level of the payload object"
    ]
  }, {
    "title": "Deprecation",
    "paragraphs": [
      "Sending arrays of payloads is no longer recomended and the batch channels should be used instead.  Please see <a href='index.html#cmapi.core.general.requirements.overview'>CMAPI Core General Requirements</a> for more details",
      "Using a widgets sender.id as a default for an overlayId is now deprecated in all cases.  It is recomended that a value always be sent for the overlayId property on any channel.  In future versions overlayId will likely become a required property."
    ]
  }]
};
cmapi.overview["cmapi.compliance.core"] = {
    "title": "CMAPI Core Compliance",
    "sections": [{
        "title": "Overview",
        "paragraphs": ["The following channels and messages comprise the core CMAPI specification.  Implementation of all of the below linked channels is required for conformance.  Within each channel, the specifics of the message processing to be implemented per channel is defined."
        ]
    },{
        "title": "Required Channels",
        "paragraphs": [
        "<a href='index.html?rf=map.overlay.create#map.overlay.create'>map.overlay.create</a>",
        "<a href='index.html?rf=map.overlay.remove#map.overlay.remove'>map.overlay.remove</a>",
        "<a href='index.html?rf=map.overlay.hide#map.overlay.hide'>map.overlay.hide</a>",
        "<a href='index.html?rf=map.overlay.show#map.overlay.show'>map.overlay.show</a>",
        "<a href='index.html?rf=map.overlay.update#map.overlay.update'>map.overlay.update</a>",
            "<a href='index.html?rf=map.feature.plot#map.feature.plot'>map.feature.plot</a>",
            "<a href='index.html?rf=map.feature.plot.batch#map.feature.plot.batch'>map.feature.plot.batch</a>",
            "<a href='index.html?rf=map.feature.unplot#map.feature.remove'>map.feature.unplot</a>",
            "<a href='index.html?rf=map.feature.unplot.batch#map.feature.unplot.batch'>map.feature.unplot.batch</a>",
            "<a href='index.html?rf=map.feature.hide#map.feature.hide'>map.feature.hide</a>",
            "<a href='index.html?rf=map.feature.show#map.feature.show'>map.feature.show</a>",
            "<a href='index.html?rf=map.feature.selected#map.feature.selected'>map.feature.selected</a>",
            "<a href='index.html?rf=map.feature.selected.batch#map.feature.selected.batch'>map.feature.selected.batch</a>",
            "<a href='index.html?rf=map.feature.deselected#map.feature.deselected'>map.feature.deselected</a>",
            "<a href='index.html?rf=map.feature.deselected.batch#map.feature.deselected.batch'>map.feature.deselected.batch</a>",
            "<a href='index.html?rf=map.feature.update#map.feature.update'>map.feature.update</a>",
            "<a href='index.html?rf=map.view.zoom#map.view.zoom'>map.view.zoom</a>",
            "<a href='index.html?rf=map.view.center.overlay#map.view.center.overlay'>map.view.center.overlay</a>",
            "<a href='index.html?rf=map.view.center.feature#map.view.center.feature'>map.view.center.feature</a>",
            "<a href='index.html?rf=map.view.center.location#map.view.center.location'>map.view.center.location</a>",
            "<a href='index.html?rf=map.view.center.bounds#map.view.center.bounds'>map.view.center.bounds</a>",
            "<a href='index.html?rf=map.view.clicked#map.view.clicked'>map.view.clicked</a>",
            "<a href='index.html?rf=map.status.request#map.status.request'>map.status.request</a>",
            "<a href='index.html?rf=map.status.view#map.status.view'>map.status.view</a>",
            "<a href='index.html?rf=map.status.format#map.status.format'>map.status.format</a>",
            "<a href='index.html?rf=map.status.about#map.status.about'>map.status.about</a>",
            "<a href='index.html?rf=map.status.selected#map.status.selected'>map.status.selected</a>",
            "<a href='index.html?rf=map.status.initialization#map.status.initialization'>map.status.initialization</a>",
            "<a href='index.html?rf=map.error#map.error'>map.error</a>"
        ]
    }]
};
cmapi.overview["cmapi.compliance.overview"] = {
    "title": "CMAPI Conformance",
    "sections": [{
        "title": "",
        "paragraphs": [
            "Conformance to the CMAPI requires, at a minimum, implementation of all if the channels and messages identified in the core specification.  ",
            "Extensions provide additional capability that compliments and extends the CMAPI core by adding new channels, and/or additional attributes to messages on existing channels. Extensions assume implementation of the core specification.  You can be CMAPI conformant without implementing any of the extensions in this section, however, IF a particular extension is implemented, it MUST be fully implemented. I.e., in order to be CMAPI conformant, if your map widget implements an extension, then your map widget MUST implement ALL of the extension and not only a part of the extension. IF an implementation only implements part of any given extension, it MUST NOT include that extension in the extensions element of a map.status.about message."
        ]

    }]
};
cmapi.overview["cmapi.core.channels.overview"] = {
	"title": "CMAPI Core Message Channels",
	"sections": [{
		"title": "Background",
		"paragraphs": [
			"CMAPI is a publish subscribe specifiation that defines JSON objects and the named channels over which they are to be transmitted.  Below are the channels used in the CMAPI COre.  Optional extensions to these channels and JSON messages as well as additional channels are defined in the CMAPI extensions section."
		]
	}]
};cmapi.overview["cmapi.core.general.requirements.batch.overview"] = {
  "title": "Batch Behavior",
  "sections": [{
    "title": "",
    "paragraphs": [
      "Batch processing allows an application to send a group of messages bundled with top level meta data.  This enables reduction of duplicate values, such as overlayId on a map.feature.plot, where 500 features are targeting the overlay.  This also allows the sending application to treat the entire batch as one message and leverage the map.message.complete to know when this batch of messages has finished processing, as well as seeing any errors raised during the processing.",
      "In previous versions of CMAPI (1.2.0 and earlier) a message payload was allowed to be either an object representing a single payload, or an array representing multiple payloads.  Beginning in CMAPI 1.2.1 developers SHOULD use the batch channels in place of arrays of payloads."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.case.overview"] = {
  "title": "Case Sensitivity",
  "sections": [{
    "title": "",
    "paragraphs": [
      "All keywords (i.e., those specifically identified in this API) in a message payload are case sensitive unless otherwise noted.",
      "Keywords and object property values SHOULD be in lower case or when they are multiple words SHOULD be be in camel case"
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.channelnaming.overview"] = {
  "title": "Channel Naming Convention",
  "sections": [{
    "title": "",
    "paragraphs": [
      "All channel names MUST be lower case with each word separated by a period (e.g., map.feature.plot).  When adding new channels, names SHOULD follow the pattern currently established. "
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.coordref.overview"] = {
  "title": "Coordinate Reference System",
  "sections": [{
    "title": "",
    "paragraphs": [
      "All latitudes and longitudes MUST be in the WGS-84 Geocentric coordinate reference system (CRS) as defined in the Open Geospatial Consortium (OGC) KML Specification Section 6.2, Coordinate Reference System and Annex B, KML Coordinate Reference System Definition.  The specification can be found at http://www.opengeospatial.org/standards/kml."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.errors.overview"] = {
  "title": "Errors",
  "sections": [{
    "title": "",
    "paragraphs": [
      "Any message sent that is missing a required attribute SHOULD result in the map application publishing an error message on the error channel. An error is also published if the map application is unable to find an object based on the given identifier. In general, any time the map is unable to complete a requested operation, an error will be published (if possible)."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.featureids.overview"] = {
  "title": "Features and Feature IDs",
  "sections": [{
    "title": "",
    "paragraphs": [
      "Features in the context of this document refer to the discrete pieces of data passed to the API. A feature may be a single marker, polygon, or a complex feature (for example, a KML or GeoJSON Document containing many sub-features). The feature ID used by the API (featureId) refers to the feature ID given when plotting the entire feature. Sub-features also have IDs but their IDs are only used in the map.feature.selected message, which contains the ID of the lowest level feature selected (if available).  Since feature IDs are required to be unique within an overlay, it is recommended to use an approach similar to the OWF channels:  use a hierarchical naming pattern with the levels of the hierarchy separated by a dot (.). To form a unique feature ID, begin with the ID of the application creating the feature ID. Then, the application can generate a unique number to complete the feature ID. For example, if generating a feature ID from an application with the name of “army.bccs.targeter”, the feature ID’s would begin with army.bccs.targeter. See Appendix D for more information on how to generate unique IDs."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.latlon.overview"] = {
  "title": "Latitude and Longitude",
  "sections": [{
    "title": "",
    "paragraphs": [
      "All latitudes and longitudes are in decimal degrees. "
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.notation.overview"] = {
  "title": "Notation",
  "sections": [{
    "title": "",
    "paragraphs": [
      "The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document, when in all capital letters, are to be interpreted as described in RFC 2119 (http://tools.ietf.org/html/rfc2119)."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.overlays.overview"] = {
  "title": "Overlays",
  "sections": [{
    "title": "",
    "paragraphs": [
      "By default, all data added by an individual application is placed into a single overlay unique to that application, which means one overlay per application. However, the API supports specifying into which overlay data are inserted, so an application can insert data in multiple overlays, and multiple applications can insert data into the same overlay. To prevent unintended merging of data due to multiple applications unintentionally using the same overlay ID, it is suggested that if an application needs to use multiple overlays, and no sharing of those overlays with other applications is intended, developers include the application ID as part of the overlay ID.  If an application needs to share overlays with other applications, developers SHOULD follow the guidelines in the OWF documentation regarding preference namespaces for shared overlays to avoid unintended collisions."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.overview"] = {
  "title": "CMAPI Core General Requirements",
  "sections": [{
    "title": "",
    "paragraphs": [
      "This section contains general guidance that applies to CMAPI behavior and documentation "
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.payloads.overview"] = {
  "title": "Payloads",
  "sections": [{
    "title": "",
    "paragraphs": [
      "With the exception of the batch channels, all Payloads SHOULD a single message payload object.  If it is desired to send an array of message payload objects in one message event, the applicable batch channel SHOULD to be used.  For backwards compatibility, arrays on any channel MUST still be supported, however arrays on these channels should be considered deprecated.  In future versions of this specification, arrays will only be supported on the batch channels."
    ]
  }]
};
cmapi.overview["cmapi.core.general.requirements.whentosend.overview"] = {
  "title": "When to Send Messages",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Any component that desires to change the state of the map or data SHALL send out the appropriate message.  If the map application is changing state via direct user input (i.e., not in response to a CMAPI message) then the map SHALL send out the appropriate message to notify other componetns of the state change.",
      "While many channels are bi-direntional (i.e., they can be sent by a application or the map) some channels have more specific use cases.  More specific expectations for each channel are covered in the given channels description."
    ]
  },{
    "title": "Example: map.overlay.hide",
    "paragraphs": [
      "If a component wishes to set the visibility of an overlay to hidden, that component will send a map.overlay.hide message and the map will respond to the message making the overlay hidden.  The Map will not send another map.overlay.hide message as the action was completed by the map and another message would be redundant. ",
      "On the other hand, if the action to hide the overlay originates within the map application\'s user interface (i.e., the map is not responding to an external message), the map will send out a corresponding map.overlay.hide message."
    ]
  },{
    "title": "Example: map.status.view",
    "paragraphs": [
      "If a component wishes to get the map's current view state, it can send a map.status.request message specifying \"view\" as the request type.  The map will then respond with a map.status.view message.",
      " Alternatively, if the map's view is changed via direct user input(i.e, the user drags the map to a different location) the map will send a map.status.view message to notify other components that the map's view has changed."
    ]
  }]
};
cmapi.overview["cmapi.core.overview"] = {
  "title": "CMAPI Core ",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This is the core of the CMAPI specification.  In order to be CMAPI conformant, all of the channels and messages in this section MUST be implemented.",
      "The channels associated with the Common Map API core specification are grouped according to the following namespaces:",
      "map.overlay channels – Messages associated with creating and manipulating overlays.",
      "map.feature channels – Messages associated with loading feature data onto the map.",
      "map.view channels – Messages associated with manipulating the map view.",
      "map.status channels – Messages associated with obtaining the current map state.",
      "map.error channels – Error messages."
    ]
  }]
};
cmapi.overview["cmapi.extensions.cluster.overview"] = {
	"title" : "Feature Clustering",
	"sections": [{
		"title": "Background",
		"paragraphs": [
			"The goal of the Common Map Widget API (CMAPI) is to enable a uniform interface for map widget implementations to make core map capabilities available to everyone. To that end, the initial specification supports the OWF Eventing and Drag & Drop APIs as two means of communicating geospatial data to a map.",
			"However, some widgets plot thousands of features onto the map, which can degrade the user experience and lead poor map performance.  In order to remedy these issues, maps can cluster results into a single feature on the map as shown in Figure 1 below.",
			"<figure><img src='img/cmapi.clustering.figure1.jpg'></img> <figcaption>Figure 1 - A screenshot of a map using clustering.</figcaption></figure>",
			"The CMAPI Technical Committee has decided to support clustering of results onto the map via an optional extension to the core CMAPI specification.  This document defines the optional clustering extension to the CMAPI core specification. Currently, this extension supports clustering multiple features into a single point feature styled using CSS color values or an icon URL. Support for additional clustering features will be added in future versions of the extension to CMAPI.",
			"Note that clustering rules are applied at the overlay level.  If it is desired to separate items into different clustering rules, then the elements should be separated into different overlays and the appropriate clustering rule set for each specific overlay."
		]
	},{
        "title": "Required Channels",
        "paragraphs": [
        "<a href='index.html?rf=map.overlay.cluster.set#map.overlay.cluster.set'>map.overlay.cluster.set</a>",
        "<a href='index.html?rf=map.overlay.cluster.remove#map.overlay.cluster.remove'>map.overlay.cluster.remove</a>",
        "<a href='index.html?rf=map.overlay.cluster.activate#map.overlay.cluster.activate'>map.overlay.cluster.activate</a>",
        "<a href='index.html?rf=map.overlay.cluster.deactivate#map.overlay.cluster.deactivate'>map.overlay.cluster.deactivate</a>",


        ]
    }]
};cmapi.overview["cmapi.extensions.manipulation.overview"] = {
  "title": "User Manipulation Extension",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This section is for both new channels and messages, as well as extensions to existing (i.e., core specification) channels and messages, that are intended to work together to support a user-oriented workflow centered on a map widget.",
      "The core specification is primarily focused supporting a workflow centered around situational awareness with limited user interactivity.  User manipulation is designed to provide a robust set of capabilities that enable interactive workflows making the relationship between an application and a map closer to the capabilities you would find when using and embedded map capability like Google Earth Plugin or OpenLayers.",
      "Examples include the user drawing, editing, and interacting with features directly on the map. It allows for chaining events via the message progress, complete, and cancel channels (e.g., do x, then do y after getting a map.message.complete event associated with x). It also allows for setting the map into a drawing or editing state, etc.",
      "Note that many of the workflows in this section are dependent on the map.message.complete, map.message.progress, and map.message.cancel messages contained within this extension.  The map.message channels enable the ability to get feedback on any message sent to the map  in the channels listed under map.message.complete and map.message.progress.  In order to use the map.message channels you MUST add an attribute to the root of the message on any of the channels (such as map.feature.plot) messageId=&quot;uuid here&quot;.  The message id will be used for any progress or complete messages sent back from the map to correlate to the original message sent. ",
      "An example of how map.message progress and complete can be useful is wanting to receive messages during a draw operation each time a point is added to a line that is being drawn by clicking on the map.  These messages would come on the map.message.progress channel with the same messageId used on the map.feature.draw message that began the draw operation.  When the user completes the draw operation, a map.message.complete message would be sent from the map with the same messageId as well.",
      "Each map.message.progress and map.message.complete payload will have a details object that is specific to the channel the original message was sent on.  The details of each of these details object is listed under the map.message.progress and map.message.complete channels.  If a channel is not listed, then map.message.progress of map.message.complete is not supported for that channel."
    ]
  },{
        "title": "Required Channels",
        "paragraphs": [
        "<a href='index.html?rf=map.message.complete#map.message.complete'>map.message.complete</a>",
        "<a href='index.html?rf=map.message.progress#map.message.progress'>map.message.progress</a>",
        "<a href='index.html?rf=map.message.cancel#map.message.cancel'>map.message.cancel</a>",
        "<a href='index.html?rf=map.feature.edit#map.feature.edit'>map.feature.edit</a>",
        "<a href='index.html?rf=map.feature.draw#map.feature.draw'>map.feature.draw</a>",
        "<a href='index.html?rf=map.feature.clicked#map.feature.clicked'>map.feature.clicked</a>",
        "<a href='index.html?rf=map.feature.mousedown#map.feature.mousedown'>map.feature.mousedown</a>",
        "<a href='index.html?rf=map.feature.mouseup#map.feature.mouseup'>map.feature.mouseup</a>",
        "<a href='index.html?rf=map.view.mousedown#map.view.mousedown'>map.view.mousedown</a>",
        "<a href='index.html?rf=map.view.area.selected#map.view.area.selected'>map.view.area.selected</a>",
        "<a href='index.html?rf=map.get#map.get'>map.get</a>",

        ]
    }]
};
cmapi.overview["cmapi.extensions.overview"] = {
  "title": "CMAPI Extensions",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This section provides details on optional extensions to the CMAPI core specification.  Extensions add addtional capability that compliments and extends the CMAPI core by adding new channels, and additonal attributes to messages on existing channels.  In order to use extensions, you MUST first implement all of the CMAPI core spec.  Note that each of the extensions in this section are optional (i.e., you can be CMAPI conformant without implementing any of the extensions in this section).  However, IF a particular extension is implemented, it MUST be fully implemented.  I.e., in order to be CMAPI conformant, if your map widget implements extension <xyz>, then your map widget MUST implement ALL of extension <xyz> and not only part of the extension.  IF an implementation only implements part of any given extension, it MUST NOT include that extension in the extensions element of a map.status.about message."
    ]
  }]
};
cmapi.overview["cmapi.overview"] = {
	"title": "CMAPI Overview",
	"sections": [{
		"title": "Background",
		"paragraphs": [
			"Many programs and projects create applications that search for or manipulate data, then present the results on a map. The desire of Common Map API (CM API) is to provide a mechanism for which developers are able to combine data search/manipulation applications from any provider with map applications from other providers. In order to accomplish this, a standard way for the data search/manipulation applications to be able to communicate with the map applications is necessary. This Application Program Interface (API) is the codification of that standard communication mechanism."
		]
	}, {
		"title": "Overview",
		"paragraphs": [
			"Using this API allows developers to focus on the problem domain rather than implementing a map application. Developers can simply reuse an existing map application that is compliant with this API . Currently, implementations using Google Earth, Google Maps V2, Google Maps V3, and OpenLayers APIs are available, and others can be written as needed.",
			"Another benefit of this API is that it allows multiple applications to collaboratively display data on a single map rather than forcing the user to have a separate map for each application so the user does not have to learn a different map user interface.",
			"CM API was originally written to be used within the OZONE Widget Framework (OWF) inter-widget communication mechanism to allow client widgets to interact with the map. However, CM API is currently being abstracted away from its OWF specific implementation and reference implementations using standard JavaScript and HTML5 cross-domain messaging have been developed. Some optional extensions may remain specific to the OWF environment, but the core required API specification will be technology agnostic. At its core, messages are sent on channels using a pub/sub model that can easily be used outside of OWF. Messages are sent to the appropriate channels, and the map updates its state accordingly. Other applications interested in knowing the current map state can subscribe to these messages as well.",
			"It is worth noting that the map itself may publish data to these channels on occasion. For example, a map.feature.selected message may originate from an application asking that a particular feature be selected or because a user has selected the feature on the map.",
			"While in most instances the map will not echo back another message to confirm that it has performed an operation, the map will send a view status message whenever the map view (zoom/pan) has been changed, either directly by the user or by another application that sent a view change message. This allows non-map applications to be aware of the current map extent without having to process all the various messages that can change the application's state.",
			"In addition, it is expected that subsequently opened applications may wish to query the map for the current state. The API, therefore, supports applications requesting the current status so they can configure themselves appropriately."
		]
	}, {
		"title": "How to use the channels and messages",
		"paragraphs": [
			"There are two ways that the map can be manipulated. The first is by other applications via the Common Map API. The second is by a user directly manipulating the map via the map Graphical User Interface (GUI) (for example, using a drawing tool on the map).",
			"To manipulate the map, applications send messages in the map channels, and the map application responds by modifying its current state. The current map state can be modified by a data source application requesting that an <a href='http://www.opengeospatial.org/standards/kml/' target='_blank'>OGC KML</a> or <a href='http://geojson.org/' target='_blank'>GeoJSON</a> file be loaded or that the view change to some other location. The map and any listening applications react to these change requests and modify their state accordingly.",
			"When the user manipulates the map, the map will post messages to the map channels, and any application listening to the map channels can respond the changes.",
			"In other words, if a feature is selected by an application request or by a user, a map.feature.selected message is sent out to any application configured to receive the message. "
		]
	}/*, {
		"title": "Structure of this Document",
		"paragraphs": [
			"This document is organized into the following four major sections: Introduction, Core Specification, User Manipulation Core, and Optional Extensions.  The Introduction provides basic background information and an overview of the channels and messages, as well as provides general requirements that apply across the board for Common Map API conformance.  The Core Specification is the minimum required channels and messages that an application MUST implement in order to be considered Common Map API compliant.  The User Manipulation Core defines those channels and messages that an application MAY implement if it is to support an end-user map oriented workflow.  However, IF an application chooses to implement the User Manipulation Core it MUST implement the whole section in order to be Common Map API – User Manipulation Core compliant.  The Optional Extensions define those messages and channels that an application MAY implement if it wishes to support the identified functionality (i.e., widget intents or clustering).  Each particular extension stands on its own, so that an application may choose which particular extensions it wants to implement on an extension by extension basis.  "
		]
	}*/]
};cmapi.overview["cmapi.references"] = {
	"sections": [{
		"title": "References",
		"paragraphs": [
			"GeoJSON specification -  <a href=\"https://tools.ietf.org/html/rfc7946\" target=\"_blank\" >https://tools.ietf.org/html/rfc7946</a>",
			"Open Geospatial Consortium KML specification -  <a href=\"http://www.opengeospatial.org/standards/kml \" target=\"_blank\" >http://www.opengeospatial.org/standards/kml</a>",
			"Google KML resources -  <a href=\"https://developers.google.com/kml/documentation/\" target=\"_blank\" >https://developers.google.com/kml/documentation/</a>",
			"Open Geospatial Consortium WMS specification -  -  <a href=\"http://www.opengeospatial.org/standards/wms\" target=\"_blank\" >http://www.opengeospatial.org/standards/wms</a>"
		]
	}]
};cmapi.overview["cmapi.runtimes.overview"] = {
  "title": "CMAPI Rutime Extensions",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "In some cases the runtime where applications are using CMAPI allows for capabilites to leverage CMAPI data formats in unique ways.  When running in the frameworks listed below these runtime specific capbilities SHOULD be implemented according to this document to ensure compatibility within the given runtime."
    ]
  }]
};
cmapi.overview["cmapi.runtimes.owf.overview"] = {
  "title": "OWF Specific Extensions",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This is for extensions that are directly and only applicable to Ozone Widget Framework (OWF) implementations."
    ]
  }]
};
cmapi.overview["cmapi.validation.overview"] = {
  "title": "Validating CMAPI messages with JSON Schemas",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "The same JSON schema files that are used to generate this documentation can also be used to validate CMAPI messages in your application.  You can test validation for each channel in the examples section on the channels documentation page.",
      "The minified distributable file with all of the CMAPI schemas is located <a href='../dist/cmapi.schema.min.js'>here</a>.",
      "<pre><code id='sampleCodeBox' class='javascript'>// cmapi.channels is defined in cmapi.schemas.min.js\n// Use the channel as the key to retrieve the correct schema\n  var schema = cmapi.channel[\"map.feature.plot\"];\n  // Create a map.feature.plot payload to validate\n  var payload ={\n    \"overlayId\": \"2d882141-0d9e-59d4-20bb-58e6d0460699.1\",\n    \"featureId\": \"example.geojson.1\",\n    \"format\": \"geojson\",\n    \"feature\": {\n      \"type\": \"Feature\",\n      \"geometry\": {\n          \"type\": \"Polygon\",\n          \"coordinates\": [[100,0],[101,0],[101,1],[100,1],[100,0]]\n      }\n    },\n    \"name\": \"Sample GeoJSON Feature\",\n    \"zoom\": true,\n    \"readOnly\": false\n  }\n// validate the payload against the schema using tv4 -  an open source javaScript JSON schema validation library\n// https://github.com/geraintluff/tv4\n  var validation =  tv4.validateMultiple(payload, schema, true);\n  if(validation.valid === true){\n    alert(\"the payload is valid\");\n  } else {\n    var errorMessage = validation.errors[0].message + \" \" + validation.errors[0].dataPath; \n    alert(\"the payload is NOT valid! \"+errorMessage);\n  }</code></pre>",
      "<a href='javascript:eval($(\"#sampleCodeBox\").html());'>Run the code sample </a>"
    ]
  }]
};
cmapi.overview["cmapi.widget-intents.overview"] = {
	"title" : "Widget Intents",
	"sections": [{
		"title": "Background",
		"paragraphs": [
			"The goal of the Common Map Widget API is to enable a uniform interface for map widget implementations to make core map capabilities available to everyone. To that end, the initial specification supports the OWF Eventing and Drag & Drop APIs as two means of communicating geospatial data to a map.",
			"With the introduction of the Widget Intents API to the OWF platform, there is a powerful new way to perform inter-widget communication in a manner that gives the user more choice and power. The Widget Intents extension to the Common Map Widget API addresses some fundamental restrictions of the Eventing-based core API. ",
			"Also, since widget intents is modeled after Android intents, it was determined by the Common Map Widget API Technical Committee that following a similar pattern of viewing and plotting appropriate mime types would be in order.  Although the “picking a common map widget” intent is unique to the Common Map Widget API, the view and plot of KML, KML URLs,  GeoJSON, and GeoJSON URLs is more generic in nature and not specific to the Common Map Widget API – and follows the already existing pattern in Android intents.  The Common Map Widget API unique addition to that is the optional common_map metadata object."
		]
	}, {
		"title": "Intents Payloads",
		"paragraphs": [
			"In keeping with best practices regarding OWF message payloads, Intents payloads should always be an Object, with a property called <b>data</b> that contains the literal data of the type described by the <b>dataType</b> property of the intent. For example:",
			"<pre><code class=\"javascript\">OWF.Intents.startActivity({<br/> action: \"view\",<br/> dataType: \"application/vnd.google-earth.kml+xml\" <br/>},<br/> {<br/> data: &lt\"?xml version=\"1.0\"?&gt&ltkml&gt…&lt\kml&gt\" <br>},<br>function(dest) {<br/> … <br/>});</pre></code>",
			"This approach also allows for the distribution of <i>always optional</i> metadata. For the Common Map Widget API, the property containing this metadata is <b>common_map</b>. This property is used to group metadata that is specifically related to the Common Map Widget API, reduce possible conflicts, and avoid polluting the top-level payload object (which is not specific to the Common Map Widget API). For example:",
			"<pre><code class=\"javascript\">OWF.Intents.startActivity({<br/> action: 'view',<br/> dataType: 'application/vnd.google-earth.kml+xml' <br/>},<br/> {<br/> data: \"&lt?xml version=\"1.0 \"?&gt&ltkml&gt…&lt/kml&gt\",<br/> common_map: {<br/> overlayId: 'abc123',<br/> featureId: 'def456',<br/> name: 'My KML', <br/> zoom: true <br/>},<br/> function(dest) {<br/> … <br/>});</pre></code>",
			"For each intent defined below, the properties identified in the <b>metadata</b> section are intended to go into the <b>data.common_map</b> object.  The identified properties are defined in the Common Map Widget API core specification, and a reference to the payload they are defined in is provided in the text.  Note that there is a potential inconsistency here between the fact that the metadata object <b>data.common_map</b> is optional, but some of the properties within the <b>data.common_map</b> object are defined as “required” in the Common Map Widget API core spec.  In these cases, when the <b>data.common_map</b> object is not sent with the given intent, the features being viewed or plotted may not be accessible to the other Common Map Widget API functions (e.g., via a map.feature.selected event)."
		]
	}]
};cmapi.overview["cmapi.widget-intents.pick.overview"] = {
	"title": "Picking a Map widget",
	"sections": [{
		"title": "Purpose",
		"paragraphs": [
			"Pick a widget that supports a specific version of the Common Map Widget API. This intent is useful for callers to obtain the GUID of an API compatible widget, for further Common Map Widget API related interaction via directed messaging (i.e., between two specific widgets vice broadcast to all)."
		]
	}, {
		"title": "Action",
		"paragraphs": [
			"pick"
		]
	}, {
		"title": "DataType",
		"paragraphs": [
			"<ul><li>application/vnd.owf.common-map-1.0</li><li>application/vnd.owf.common-map-1.1</li><li>application/vnd.owf.common-map-1.2</li></ul>",
			"When doing a “pick”, a widget should ask for the lowest possible version of the Common Map Widget API that is needed to accomplish its desired functionality in order to ensure the widest possible selection of widgets to pick from."
		]
	}, {
		"title": "Metadata",
		"paragraphs": [
			"none"
		]
	}, {
		"title": "Example - Receiving Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\">OWF.Intents.receive(<br/>  { action: 'pick', dataType: 'application/vnd.owf.common-map-1.0' }, <br/>  function(sender, intent, data) {<br/>    // no-op<br/>}<br/>);</code></pre>",
			"In the OWF.Intents.recieve, the receiver of the intent SHOULD NOT take any action as a result of the intent.  This is to maintain a common user experience when implementing the pick intent"
		]
	}, {
		"title": "Example - Sending Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\">OWF.Intents.startActivity(<br/>  { action: 'pick', dataType: 'application/vnd.owf.common-map-1.0’ }, <br/>  { },<br/>  function(dest) { … }<br/>);</code></pre>",
			"In OWF.Intents.startActivity, the payload SHOULD be empty (i.e., no actual data is conveyed in the map widget pick intent).  An example use case that this supports is for an end user to connect a specific data widget with a specific map widget for further directed communications via the Common Map Widget API. "
		]
	}]
};cmapi.overview["cmapi.widget-intents.plot.overview"] = {
	"title": "Plotting Data",
	"sections": [{
		"title": "Purpose",
		"paragraphs": [
			"Plot KML or GeoJSON data, meaning visualize specifically on a <i>geospatial</i> display, not just any widget that is can accept KML or GeoJSON."
		]
	}, {
		"title": "Action",
		"paragraphs": [
			"plot"
		]
	}, {
		"title": "DataType",
		"paragraphs": [
			"<ul><li>application/vnd.google-earth.kml+xml</li><li>application/geo+json</li><li>uri-list/vnd.google-earth.kml+xml</li><li>uri-list/geo+json</li></ul>"
		]
	}, {
		"title": "Metadata",
		"paragraphs": [
			"The following properties from the <b>map.feature.plot</b> payload: <ul><li>overlayId</li><li>featureId</li><li>name</li><li>zoom</li></ul>"
		]
	}, {
		"title": "Notes",
		"paragraphs": [
			"When the optional metadata is included in this intent, the receiving widget’s behavior SHOULD be the same as if a map.feature.plot message was sent (see Common Map Widget API Version 1.2 core specification for more details on the map.feature.plot message).  Although the map.feature.plot states featureId is required, featureId is optional for the plot intents.  If the featureId is not provided, the receiving map SHALL plot the feature and use a locally generated id if needed for internal tracking purposes.  If the featureId is omitted, the map SHALL NOT be required to support any of the other common map API commands such as map.feature.selected or map.feature.update that require a featureId.",
			"When the optional metadata IS NOT included in this intent, the receiving widget’s behavior SHOULD be the same as if a map.feature.plot message was sent with the exception that the feature may not be selectable or otherwise manipulate-able via the Common Map Widget API at a later time due to the fact that there is not a featureId associated with the data being passed in."
		]
	}, {
		"title": "Example - Receiving Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\"OWF.Intents.receive(<br/>  { action: 'plot', dataType: 'application/vnd.google-earth.kml+xml' },<br/>   function(sender, intent, data) {  <br/>    // check for common_map metadata<br/>    if(data.common_map) {<br/><br/>      if(data.common_map.overlayId){…}<br/>      if(data.common_map.featureId){…}<br/>      if(data.common_map.name){…}<br/>      if(data.common_map.zoom){…}<br/>    }    // visualize KML in data.data<br/>  }<br/>);</code></pre>"
		]
	}, {
		"title": "Example - Sending Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\">OWF.Intents.startActivity(<br/>  { action: 'plot', dataType: 'application/vnd.google-earth.kml+xml' }, <br/>  { <br/>    data: '&lt?xml version=\"1.0\"?&gt&ltkml&gt…&lt/kml&gt',<br/>    common_map: {<br/>      overlayId: 'abc123',<br/>      featureId: 'def456',<br/>      name: 'My Geo Data',<br/>      zoom: true<br/>    }<br/>  }<br/>  function(dest) { … }<br/>);</code></pre>"
		]
	}]
};cmapi.overview["cmapi.widget-intents.view.overview"] = {
	"title" : "Viewing Data",
	"sections": [{
		"title": "Purpose",
		"paragraphs": [
			"Visualize KML or GeoJSON feature data directly, or via URLs."
		]
	},{
		"title": "Action",
		"paragraphs": [
			"view"
		]
	}, {
		"title": "DataType",
		"paragraphs": [
			"<ul><li>application/vnd.google-earth.kml+xml</li><li>application/geo+json</li><li>uri-list/vnd.google-earth.kml+xml</li><li>uri-list/geo+json</li></ul>"
		]
	},{
		"title": "Metadata",
		"paragraphs": [
			"The following properties from the <b>map.feature.plot</b> payload: <ul><li>overlayId</li><li>featureId</li><li>name</li><li>zoom</li><li>readOnly</li></ul>"
		]
	},
	{
		"title": "Notes",
		"paragraphs": [
			"When the optional metadata is included in this intent, the receiving widget’s behavior SHOULD be the same as if a map.feature.plot message was sent (see Common Map Widget API Version 1.2 core specification for more details on the map.feature.plot message).  Although the map.feature.plot states featureId is required, featureId is optional for the plot intents.  If the featureId is not provided, the receiving map SHALL plot the feature and use a locally generated id if needed for internal tracking purposes.  If the featureId is omitted, the map SHALL NOT be required to support any of the other common map API commands such as map.feature.selected or map.feature.update that require a featureId.</p><p>When the optional metadata IS NOT included in this intent, the receiving widget’s behavior SHOULD be the same as if a map.feature.plot message was sent with the exception that the feature may not be selectable or otherwise manipulate-able via the Common Map Widget API at a later time due to the fact that there is not a featureId associated with the data being passed in."
		]
	},{
		"title": "Example - Receiving Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\">OWF.Intents.receive(<br/>{ action: 'view', dataType: 'application/vnd.google-earth.kml+xml' }, <br/> function(sender, intent, data) {<br/> // check for common_map metadata <br/>if(data.common_map) {<br/>if (data.common_map.overlayId){…}<br/> if (data.common_map.featureId){…}<br/>if (data.common_map.name){…}<br/>if (data.common_map.zoom){…}<br/>    }<br/>// visualize KML in data.data<br/>};</code></pre>"
			]
	}, {
		"title": "Example - Sending Widget",
		"paragraphs": [
			"<pre><code class=\"javascript\">OWF.Intents.startActivity(<br/> { action: 'view', dataType: 'application/vnd.google-earth.kml+xml' }, <br/> { <br/>  data: '&lt?xml version=\"1.0\"?&gt&ltkml&gt…&lt/kml&gt',<br/>  common_map: {<br/>   overlayId: 'abc123',<br/>   featureId: 'def456',<br/>   name: 'My Geo Data',<br/>   zoom: true<br/>  }<br/> },<br/> function(dest) { … }<br/>);</code></pre>"
			]
	}]
};cmapi.overview["map.feature.formats.overview"] = {
  "title": "map.feature data formats",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This section provides amplifying detail and normative statements concerning the allowable and required formats for the feature data referenced in the map.feature namespace. It is anticipated that communities of interest (COI) will add subsections to this section for feature formats that are applicable to their COI."
    ]
  }]
};
cmapi.overview["map.feature.overview"] = {
  "title": "map.feature namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for those messages and channels associated with loading feature data on a map.  Note that all feature data is associated with a specific overlay, whether the default overlay or with specifically identified overlays.  Features can be in various formats.  The map.feature.plot message will identify what formats are required.  See the Feature Data Formats section for amplifying detail and normative statements concerning the allowable and required formats for the feature data referenced in this namespace."
    ]
  }]
};
cmapi.overview["map.feature.plot.formats.overview"] = {
  "title": "Data formats supported in map.feature channels",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "This sections lists the data formats supported in the map.feature channels as well as implementation details for each format."
    ]
  }]
};
cmapi.overview["map.feature.plot.kml"] = {
  "title" : "map.feature.plot - KML",
	"sections": [{
		"title": "map.feature.plot - KML",
		"paragraphs": [
			"Implementers of the Common Map Widget API MUST support at least as much of the official KML spec (<a href=\"http://www.opengeospatial.org/standards/kml\" >http://www.opengeospatial.org/standards/kml</a>) as is highlighted in Figure A.1.",
			"<figure><img src='img/kml.diagram.figureA1.jpg'></img> <figcaption>Figure A.1 - Minimum support for KML</figcaption></figure>"
		]
	}]
};cmapi.overview["map.message.overview"] = {
  "title": "map.message namespace ",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for map.message channels that enable feedback for message progress and completion for messsages sent via other channels. The map.message channels require that an attribute messageId be added to the message payload for any message you wish to get a message complete or message progress event.  The messageId MUST be a unique id which will be used for the duration of a single message.  The channels that support message complete and message progress are listed under those channels."
    ]
  }]
};
cmapi.overview["map.overlay.cluster.overview"] = {
  "title": "map.overlay.cluster namespace ",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for map.overlay.cluster that allow control for how points within an overlay get clustered or decluttered for display on the map"
    ]
  },{
        "title": "Required Channels",
        "paragraphs": [
        "<a href='index.html?rf=map.overlay.cluster.set#map.overlay.cluster.set'>map.overlay.cluster.set</a>",
        "<a href='index.html?rf=map.overlay.cluster.remove#map.overlay.cluster.remove'>map.overlay.cluster.remove</a>",
        "<a href='index.html?rf=map.overlay.cluster.activate#map.overlay.cluster.activate'>map.overlay.cluster.activate</a>",
        "<a href='index.html?rf=map.overlay.cluster.deactivate#map.overlay.cluster.deactivate'>map.overlay.cluster.deactivate</a>",


        ]
    }]
};
cmapi.overview["map.overlay.cluster.references"] = {
	"title" : "Clustering: References",
	"sections": [{
		"title": " ",
		"paragraphs": [
			"Too Many Markers by Luke Mahe and Chris Broadfoot  -  <a href=\"https://developers.google.com/maps/articles/toomanymarkers\" target=\"_blank\" >https://developers.google.com/maps/articles/toomanymarkers</a>"
		]
	}]
};cmapi.overview["map.overlay.cluster.replaceableParameters"] = {
	"title" : "Clustering: Replaceable Parameters",
	"sections": [{
		"title": " ",
		"paragraphs": [
			"When clustering multiple features into a single feature, it is important to allow the clustered feature to contain style and information from the features in the cluster. As requirements evolve, additional replaceable values and functionality will be added to this document to cover all supported features.",
			"Replacement currently requires the value sent in the map.overlay.cluster.set channel to be expressed as a string so it can be evaluated by the map. These replaceable parameters are represented using the following syntax, ${param} where param represents the name of the replaceable parameter from the following list:",
			"ParameterName = <b>count</b>; Parameter Description = The number of features in the clustered feature."
			
		]
	}]
};cmapi.overview["map.overlay.clustering.channels.overview"] = {
  "title": "Clustering Message Channels",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Feature clustering is handled within the new map.overlay.cluster namespace with the addition of four channels"
    ]
  }, {
    "title": "Clustering Channels",
    "paragraphs": [
      "map.overlay.cluster.set",
      "map.overlay.cluster.remove",
      "map.overlay.cluster.activate",
      "map.overlay.cluster.deactivate"
    ]

  }]
};
cmapi.overview["map.overlay.overview"] = {
  "title": "map.overlay namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for those messages and channels associated with creating and manipulating overlays.  Overlays can be thought of as a container for features and map data."
    ]
  }]
};
cmapi.overview["map.overview"] = {
  "title": "map namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Top level namespace for a channels in the CMAPI specification."
    ]
  }]
};
cmapi.overview["map.status.overview"] = {
  "title": "map.status namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for those messages and channels associated with obtaining the current state of the map (e.g., what versions of CMAPI does the map support, what are the bounds of the map that are currently being displayed, etc.)."
    ]
  }]
};
cmapi.overview["map.view.area"] = {
  "title": "map.view.area namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for those messages and channels that are associated with the map view area (i.e., what portion of the map view the end user is interested in)."
    ]
  }]
};
cmapi.overview["map.view.center.overview"] = {
  "title": "map.view.center namespace ",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for map.view operations that center on entites such as an overlay, feature, or area"
    ]
  }]
};
cmapi.overview["map.view.overview"] = {
  "title": "map.view namespace",
  "sections": [{
    "title": "Overview",
    "paragraphs": [
      "Namespace for those messages and channels that are associated with manipulating the map view (i.e., what portion of the map is displayed to the end user)."
    ]
  }]
};
